Intent

  This library depends on hardware and compiler specific features.

  The intention is to abstract these features away from code that
  uses the library.

Problem

  Both SSE and Altivec require data to be aligned on 16 byte
  boundaries. They both provide C language types as compiler
  extensions:

        SSE   __m128         128 bit single precision vector
       SSE2   __m128d        128 bit double precision vector
    Altivec   vector float   128 bit single precision vector

  Code using the library needs to use these types but at the
  same time, must be unaware that it is using them.

Current solution

  Compiler extensions and hardware are detected at library
  compile time. Preprocessor defines are imported by the
  private library header v_simd.h, via _sysinfo.h.

  No publically visible header file imports this header file.
  This ensures that client code is effectively unaware of
  any hardware specific information.

  The executable program, vector-conf, is provided to be used
  by client code. When executed, it outputs compiler flags:

    $ vector-conf cflags newline
    -DSYS_HAVE_CPU_EXT_SSE -msse

    $ vector-conf compile incdir newline
    -I/usr/local/include/coreland

  This allows client code to do:

    cc -c -o prog.o prog.c `vector-conf cflags compile incdir`
    cc -o prog prog.o `./vector-conf slibdir compile ldflags`

Rationale

  Given that client code is not even supposed to be aware
  that the library uses hardware specific features, it is
  unreasonable for client code to be expected to do the exact
  same compile-time hardware detection as the library.

  Systems such as Mac OS X use 'universal binaries', where
  executable code for multiple architectures is kept in
  single binaries and the compiler picks the correct architecture
  at compile time. This, however, means that no hardware
  specific information can be kept in publically visible headers
  so it is not possible for the library to do something similar
  to:

    cat >> vector.h <<EOF
    #define HAVE_SSE
    #define HAVE_SSE2
    EOF

  The only real alternative, therefore, is to hold compiler
  flags in a program for client code to execute. This works
  cleanly on universal binary systems as the correct version
  of the executable is run transparently.

Issues

  This solution is still not very satisfactory. It does not
  work on systems that have multiple, incompatible compilers -
  one version of the library is needed for each compiler and
  client code must be aware of which compiler each library
  was compiled with.
